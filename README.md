# 📌프로젝트 개요
<p align="center">
  <img
    width="800"
    src="https://github.com/user-attachments/assets/3b6c3139-b4d0-4037-8176-a2af6bdd9d6d"
    alt="algorithm" />
</p>

A*와 JPS 알고리즘을 웹 시뮬레이터로 분석하며 규칙을 정리한 뒤, 별도의 참고 자료 없이 직접 구현했습니다.  

데이터 처리보다는 시각화에 초점을 두어 Win32 API로 길찾기 과정을 실시간으로 확인할 수 있도록 구현했습니다.

| 항목 | 내용 |
|------|------|
| 📹 소개 영상 | [A* 알고리즘](https://www.youtube.com/watch?v=LJFaqtHtj8k&feature=youtu.be) / [JPS 알고리즘](https://www.youtube.com/watch?v=thwqsdws0BQ) |
| 🕒 개발 기간 | 2023.03.22 ~ 2023.04.03 (12일) |
| 👤 개발 인원 | 1명 |
| 🧰 개발 환경 | C, Win32API, VS2022 |

</br>

# 📘목차
- [구현 내용](#구현-내용-목차-이동)
- [핵심 주요 코드](#핵심-주요-코드-목차-이동)
- [문제 해결 경험(트러블 슈팅)](#문제-해결-경험트러블-슈팅-목차-이동)
- [프로젝트에서 얻은 것](#프로젝트에서-얻은-것-목차-이동)
- [개발 계기](#개발-계기-목차-이동)

</br>

# 📘구현 내용 [(목차 이동)](#목차)

| 구현 내용 | 구현 요약 |
|-----------------------------------------|-----------|
| 타일 편집 & 입력 처리 | 마우스 좌표를 그리드 인덱스로 변환해 시작/도착/벽 타일 값을 설정하고, 드래그 기반으로 맵을 편집할 수 있는 UI 없이 로직 중심 편집 기능 구현 |
| 타일 상태 시각화 | 타일 상태(시작 위치, 벽, 최종 경로)를 색상과 심볼로 구분해, A* / JPS 탐색 과정을 한눈에 확인할 수 있도록 시각화 |
| A* / JPS 길찾기 알고리즘 | A*와 JPS 알고리즘을 각각 구현하고, 탐색 진행 과정을 실시간으로 그려 시각적으로 확인할 수 있도록 구성 |

</br>

# 📘핵심 주요 코드 [(목차 이동)](#목차)

| 코드 파일 | 코드 설명 |
|----------|-----------|
| JPS 알고리즘 / [.cpp](https://github.com/Myoungcholho/JPS_Algorithm/blob/master/Win32JPS/Win32JPS.cpp) | JPS 구현 코드이며, Win32 기반의 버튼 UI와 마우스 피킹 기능을 포함한 메인 로직입니다. |
| A* 알고리즘  / [.cpp](https://github.com/Myoungcholho/AStarAlgorithm/blob/main/Win32GridTileTest/Win32GridTileTest.cpp) | A* 구현 코드이며, Win32 기반의 버튼 UI와 마우스 피킹 기능을 포함한 메인 로직입니다. |

</br>

# 📘문제 해결 경험(트러블 슈팅) [(목차 이동)](#목차)

<table style="border-collapse:collapse;">
  <tr>
    <th width="350" style="border:2px solid #a8ddff; background:#e6f6ff;">
      📘 코너 처리 오류로 불필요한 노드 생성
    </th>
    <th width="350" style="border:2px solid #c8ffa8; background:#ebffdf;">
      📂 무한 루프 발생
    </th>
  </tr>

  <tr>
    <td width="350" style="border:2px solid #a8ddff; background:#e6f6ff; vertical-align:top;">
      코너 미처리로 JPS가 불필요한 타일까지 탐색하던 문제를, 코너 예외 처리를 추가해 해결했습니다.
      <br><br>
      <a href="#t3">[상세설명]</a>
    </td>
    <td width="350" style="border:2px solid #c8ffa8; background:#ebffdf; vertical-align:top;">
      탐색한 타일을 별도로 관리하지 않아 무한 루프가 발생했으며, 이를 탐색 이력 데이터를 분리해 관리하는 방식으로 해결했습니다.
      <br><br>
      <a href="#t4">[상세설명]</a>
    </td>
  </tr>
</table>

## 1. 코너 처리 오류로 불필요한 노드 생성 <a id="t3"></a> [(트러블 슈팅 목록 이동)](#문제-해결-경험트러블-슈팅-목차-이동)

<table>
  <tr>
    <td style="border:2px solid #4fa3ff; border-radius:8px; padding:12px 16px; background:#050812;">
      <strong>🧩 문제</strong><br>
      <ul>
        <li> JPS 알고리즘에서 계단형 지형의 장애물 주변 노드가 불필요하게 계속 생성되는 문제가 발생 </li>
      </ul>
      <strong>🔍 원인 분석</strong>
      <ul>
        <li> 장애물 인접 구간에서 대각선으로 노드를 확장할 때, 코너(Corner) 충돌 여부를 판단하는 로직이 부족했음 </li>
      </ul>
      <strong>🛠 해결</strong>
      <ul>
        <li> 대각선으로 확장하기 전, 우회 가능 여부를 검사하는 조건을 추가하여 장애물을 끼고 돌아갈 수 없는 경우에는 대각선 확장을 막도록 수정함 </li>
      </ul>
      <strong>📚 배운 점</strong>
      <ul>
        <li> 코너 같은 특수 예외는 실제로 코드 짜서 돌려보기 전엔 잘 안 보인다는 걸 깨달음 </li>
        <li> 논리적으로 이해하는 것만큼이나, 직접 구현·실행해 보면서 얻는 정보도 크다는 것을 체감함 </li>
      </ul>
    </td>
  </tr>
</table>

---

## 2. 무한 루프 발생 <a id="t4"></a> [(트러블 슈팅 목록 이동)](#문제-해결-경험트러블-슈팅-목차-이동)

<table>
  <tr>
    <td style="border:2px solid #c8ffa8; border-radius:8px; padding:12px 16px; background:#060f06;">
      <strong>🧩 문제</strong>
      <ul>
        <li> 이미 탐색이 끝난 위치가 다시 생성되면서, 동일 지점을 반복 탐색하는 루프가 발생 </li>
      </ul>
      <strong>🔍 원인 분석</strong><br>
      <ul>
        <li> 탐색이 끝난 위치는 List에서 제거해 탐색이 끝났는지의 여부의 데이터가 소실되었기 때문 </li>
      </ul>
      <strong>🛠 해결</strong><br>
      <ul>
        <li> 방문을 완료한 List 컨테이너 를 두어 한 번 사용된 노드의 좌표를 기록하고, 이미 방문한 좌표는 이후 탐색 대상에서 제외하도록 처리함 </li>
      </ul>
      <strong>📚 배운 점</strong>
      <ul>
        <li> List를 매번 정렬하는 비용을 고려하면, 우선순위 큐(힙)를 사용하는 편이 훨씬 적절했다는 걸 깨달음 </li>
        <li> 이 경험을 계기로, 알고리즘에 맞는 컨테이너를 고르기 위해 여러 자료구조를 더 깊게 학습하게 됨 </li>
      </ul>
    </td>
  </tr>
</table>

</br>

# 📘프로젝트에서 얻은 것 [(목차 이동)](#목차)

| 번호 | 얻은 경험 |
|------|-----------|
| 1 | [검증 가능한 결과를 만드는 개발 방식](#gain-drawcall) |
| 2 | [모듈 단위 개발의 중요성](#gain-ue-arch) |
| 3 | [코드로 검증하는 개발 방식](#gain-cpp-resource) |

---

### 1. 검증 가능한 결과를 만드는 개발 방식 <a id="gain-drawcall"></a> [(⬆표로 이동)](#프로젝트에서-얻은-것-목차-이동)

알고리즘을 실제 코드로 구현했을 때, 제대로 동작하는지와 최단 경로가 맞는지를 검증하는 과정이 데이터만으로는 매우 까다롭다는 것을 느꼈습니다.
단순히 숫자 데이터만 확인하는 데에는 한계가 있었고, 실제로 화면에 시각화해 로직의 흐름을 눈으로 확인했을 때 훨씬 명확하게 검증할 수 있었습니다.

이 경험을 통해, 수치만으로 검증하기 어려운 것은 화면, 기록, 시각화 등 다양한 형태로 결과를 만들어 확인하는 습관이 중요하다는 점을 깨달았습니다.

---

### 2. 모듈 단위 개발의 중요성 <a id="gain-ue-arch"></a> [(⬆표로 이동)](#프로젝트에서-얻은-것-목차-이동)

처음부터 전체를 어떻게 짤지 고민했지만, 머릿속에서 정리가 잘 되지 않아 진전도 제대로 되지 않았습니다.
그래서 거리를 계산하는 로직, 타일을 검사하는 로직처럼 기능을 모듈화해 순차적으로 개발해 보면서, 이쪽이 훨씬 더 정리가 잘 되고 구현도 수월하다는 것을 직접 느꼈습니다.

이 경험을 통해 처음부터 완전한 것을 만들려고 하기보다, 모듈 단위로 나눠 개발하는 습관을 가지게 되었습니다.

---

### 3. 코드로 검증하는 개발 방식 <a id="gain-cpp-resource"></a> [(⬆표로 이동)](#프로젝트에서-얻은-것-목차-이동)

알고리즘을 ‘이해하는 것’과 그걸 ‘코드로 구현하는 것’은 확실히 다르다는 걸 느꼈습니다.
직접 구현해 보면서, 알고리즘을 어떤 컨테이너로 관리해야 하는지, 방어 코드는 어디에 들어가야 하는지 같은 세부 사항을 몸으로 익힐 수 있었습니다.

이 경험을 통해, 개발자는 결국 직접 코드를 쳐 보면서 배우는 것이 가장 중요하다는 사실을 다시 한 번 깨달았습니다.

</br>

# 📘개발 계기 [(목차 이동)](#목차)
### 알고리즘을 실제 눈으로 확인하고 싶어서

알고리즘·자료구조를 공부하다가, A* 길찾기가 실제로 어떤 순서로 타일을 탐색하며 최적 경로를 찾는지 직접 확인하고 싶었습니다.  
그래서 Win32 API를 사용해 A*를 직접 구현하고, 디버깅과 시각화를 함께 경험하는 길찾기 프로젝트를 진행했습니다.
