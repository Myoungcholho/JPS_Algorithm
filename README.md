# 📘Win32 길찾기 알고리즘 프로젝트
<br>
<img align="right" width="420"
     src="https://github.com/user-attachments/assets/57de145d-e166-401a-9226-e23cdd8ca2b8"
     alt="DirectX 11 Engine Editor Screenshot" />


- 소개 영상: [A* 알고리즘](https://www.youtube.com/watch?v=LJFaqtHtj8k&feature=youtu.be) / [JPS 알고리즘](https://www.youtube.com/watch?v=thwqsdws0BQ)
- 개발 기간: 2023.03.22 ~ 2023.04.03 (12일)
- 개발 인원: 1인
- 핵심 요약: A*와 JPS 알고리즘을 직접 구현하여, 두 알고리즘 간의 성능 차이와  
   구조적 특징을 시각적으로 비교할 수 있는 Win32 기반 길찾기 시뮬레이터 개발
- 개발 환경: C, Win32API, VS2022

<br clear="both"/>

# 📘목차
- [개발 계기](#개발-계기)
- [아쉬웠던 점](#아쉬웠던-점)
- [프로젝트에서 얻은 것](#프로젝트에서-얻은-것)
- [구현 내용](#구현-내용)
- [문제 해결 경험(트러블 슈팅)](#문제-해결-경험트러블-슈팅)
- [핵심 주요 코드](#핵심-주요-코드)

# 📘개발 계기
### 알고리즘을 실제 눈으로 확인하고 싶었습니다.

C언어로 기본 알고리즘과 자료구조를 학습하던 중,  
A* 알고리즘이 실제로 어떻게 탐색을 진행하고 최적 경로를 찾는지  
시각적으로 보고 싶다는 생각이 들었습니다.

그래서 직접 구현 + 디버깅 + 시각화 과정을 경험하기 위해  
Win32 API를 사용해 길찾기 과정을 UI없이 순수 로직 기반으로  
표현한 프로젝트를 진행하게 되었습니다.


# 📘아쉬웠던 점

**요약**
- [1. 데이터 구조 선택 부족](#weak-arch)
- [2. 시각화 구조 설계 부족](#weak-optim)
- [3. 더블 버퍼링 미구현으로 인한 화면 깜빡임](#weak-optim2)
---

### 1. 데이터 구조 선택 부족 <a id="weak-arch"></a>

초기 구현에서 노드를 단순 리스트로 관리하여 탐색 속도가 느렸고,  
Priority Queue를 활용하는 구조가 더 적합했음을 뒤늦게 깨달았습니다.

다음 알고리즘 프로젝트에서는 자료 구조 선택부터 신중하게 접근하려 합니다.

---

### 2. 시각화 구조 설계 부족 <a id="weak-optim"></a>

탐색 영역을 임의 색상으로 표시하다 보니 경로 분석이 어려웠습니다.  
최종 경로를 붉은색 라인으로 시각화하는 개선을 적용하여 디버깅 효율이 크게 향상됐습니다.

---

### 3. 더블 버퍼링 미구현으로 인한 화면 깜빡임 <a id="weak-optim2"></a>

Win32 GDI로 바로 그리는 방식만 사용해서,  
길 탐색 과정에서 화면이 매 프레임 갱신될 때마다 번쩍거리는  
깜빡임(flickering) 문제가 있었습니다.

당시에는 더블 버퍼링을 적용하지 않아 발생한 문제였고,  
이 경험을 통해 "화면에 직접 그리는 것"과  
"버퍼에 그린 뒤 한 번에 교체하는 것"의 차이를 인지하게 되었습니다.

이후 진행한 DirectX 11 프로젝트에서 SwapChain과  
백 버퍼 → 프론트 버퍼 교체 과정을 이해하는 데  
이 경험이 큰 도움이 되었다고 느꼈습니다.

# 📘프로젝트에서 얻은 것

**요약**
- [1. 시각화 기반 디버깅의 중요성](#project01)
- [2. 하나씩 쌓아가는 방식의 필요성](#project02)
- [3. 구현 중심 사고의 장점](#project03)

---

### 1. 시각화 기반 디버깅의 중요성 <a id="project01"></a>

탐색 구역 색 표시, 최종 경로 강조, Corner case 예외 처리 등  
디버깅 시 시각 정보가 이해도 상승과 오류 감소에 크게 기여함을 체감했습니다.

---

### 2. 하나씩 쌓아가는 방식의 필요성 <a id="project02"></a>

처음부터 완전체를 만들려 하기보다,  
거리 계산 → 주변 타일 검사 → 대각선 처리 → Path 연결  
이처럼 모듈을 분리해 개발하는 방식이 효율적임을 깨달았습니다.

---

### 3. 구현 중심 사고의 장점 <a id="project03"></a>

알고리즘 설명만으로는 이해가 부족했지만,  
직접 구현하고 시각화하면서 알고리즘의 작동 구조를 명확히 이해했습니다.

# 📘구현 내용

- 마우스 좌표 기반 타일 값 설정 및 편집 UI
- 타일 상태(벽, 길, 탐색 영역, 경로) 시각화
- A* 알고리즘 구현 / JPS 알고리즘 구현

# 📘문제 해결 경험(트러블 슈팅)

**요약**
- [1. 코너 처리 오류로 불필요한 노드 생성](#tag01)
- [2. 무한 루프 발생](#tag02)

### 1. 코너 처리 오류로 불필요한 노드 생성 <a id="tag01"></a>

- 문제 상황

계단형 구조에서 노드가 불필요하게 계속 생성되었습니다.  

- 원인

장애물 근처 대각선 확장 시 Corner 판단 로직 부족했습니다.  

- 해결

대각선 확장 시 우회 가능 여부 검사 로직 추가해 해결했습니다.  


- 배운 점  

JPS의 경우 시뮬레이터를 여러 번 돌려보며 로직을 유추하는 방식으로  
진행하다 보니, 코너에서 발생하는 특수 예외들은 직접 구현하고  
눈으로 확인해 보기 전까지는 파악하지 못했습니다.

머리로 논리를 이해하는 것도 중요하지만,  
결국 코드 단위로 녹여내고 실행해 보는 과정에서만  
얻을 수 있는 인사이트가 있다는 것을 느꼈습니다.

---

### 2. 무한 루프 발생 <a id="tag02"></a>

- 문제 상황
  
이미 탐색된 위치를 다시 생성하면서 루프 발생  

- 해결
  
closeList 추가, 사용된 노드 좌표 기록 후 탐색 제외 처리  

- 결과
  
정상 탐색 및 안정성 확보  


- 배운 점  

되돌아보면, `List` 자료구조를 선택한 것은 좋은 선택이 아니었습니다.  
우선순위가 가장 낮은 타일을 먼저 탐색하는 것이 논리상 맞지만,  
이를 위해 매번 리스트를 정렬하면서 `O(n log n)`의 비용을 지불하고 있었기 때문입니다.

우선순위 큐(힙) 자료구조를 사용했다면,  
정렬된 상태를 유지한 채로 가중치가 낮은 타일을 꺼낼 수 있었고,  
`O(log n)`의 시간 복잡도로 처리할 수 있었을 것입니다.

이 경험을 통해 알고리즘을 뒷받침하는 컨테이너 선택도  
구현 전에 신중하게 고민해야 한다는 것을 깨달았습니다.

---


# 📘핵심 주요 코드
- [JPS 알고리즘](https://github.com/Myoungcholho/JPS_Algorithm/blob/master/Win32JPS/Win32JPS.cpp)
- [A* 알고리즘](https://github.com/Myoungcholho/AStarAlgorithm/blob/main/Win32GridTileTest/Win32GridTileTest.cpp)
